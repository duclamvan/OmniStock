Rozum칤m, soust콏ed칤me se tedy **pouze na "Feature 1": Virtu치ln칤 produkty (Kbel칤ky vs. D칩zy)** a archivaci odlo쮂셠e.

Zde je detailn칤 pl치n a p콏ipraven칳 prompt pro Replit, kter칳 je mnohem podrobn캩j코칤 a technicky p콏esn캩j코칤, aby to AI pochopila na prvn칤 pokus.

### Jak to bude fungovat (Technick칳 design)

Nebudeme vytv치콏et slo쬴t칠 "bal칤캜ky". Ud캩l치me to elegantn캩 p콏es **"Rodi캜ovsk칳 produkt"**.

1.  **Produkt A (Rodi캜):** `Acrylic Powder 660g` (Fyzicky existuje na sklad캩).
2.  **Produkt B (Virtu치ln칤):** `Acrylic Powder 25lbs Bucket` (Neexistuje fyzicky).
    * V datab치zi bude m칤t nastaveno: *"Jsem jen odkaz na Produkt A a spot콏ebuju jich 17."*

Kdy n캩kdo koup칤 **Produkt B**, syst칠m na pozad칤 s치hne do skladu **Produktu A** a ode캜te **17 kus콢**.

---

### 游늶 Replit Prompt (Vylep코en칳 pro Feature 1)

Zkop칤rujte tento text do Replitu. Je v angli캜tin캩 (pro AI), ale obsahuje v코echny va코e specifick칠 po쬬davky ("Strict 17 Rule").

> **I need to implement a "Virtual SKU" system for my Warehouse Management App (Davie Supply) using Drizzle ORM and TypeScript.**
>
> **The Goal:**
> I sell products in different packaging sizes, but I only stock the smallest unit.
> * **Example:** I stock "Acrylic Powder (Jar 660g)".
> * **Virtual Item:** I also sell "Acrylic Powder (Bucket 25lbs)".
> * **The Rule:** 1 Bucket = STRICTLY 17 Jars.
> * When a user orders a Bucket, the system must deduct 17 Jars from the inventory.
>
> **Step 1: Database Schema Updates (`products` table)**
> Please modify the `products` table schema to add self-referencing capabilities:
> 1.  `masterProductId`: A text/varchar column that references `products.id`. This links a virtual product to its physical parent.
> 2.  `inventoryDeductionRatio`: An integer column (default 1). This defines how many units of the master product are consumed (e.g., 17).
>
> **Step 2: Inventory Logic (`deductInventory` service)**
> Update my backend inventory deduction logic. When an order is packed:
> 1.  Fetch the sold product's details.
> 2.  **Check if `masterProductId` exists.**
>     * **IF YES (It's a Bucket):**
>         * Target Product for deduction = `masterProductId`.
>         * Quantity to Deduct = `Sold Quantity` * `inventoryDeductionRatio` (e.g., 1 * 17).
>         * *Audit Log Note:* Record that this was a virtual sale (e.g., "Sold 1x Bucket, deducted 17x Jars").
>     * **IF NO (Standard Item):**
>         * Target Product = The product itself.
>         * Quantity to Deduct = `Sold Quantity`.
>
> **Step 3: Frontend "Available Stock" Calculation**
> In the Product List and Order creation screens, the "Stock" for a Virtual Product (Bucket) should be calculated dynamically:
> * `Bucket Stock` = `Math.floor(MasterProduct.Stock / inventoryDeductionRatio)`
> * Do not store stock for the Bucket directly; always derive it from the Master.
>
> **Please implement the schema changes and the updated service functions.**

---

### Co tento prompt zajist칤?

1.  **Datab치ze:** P콏id치 sloupce `masterProductId` a `inventoryDeductionRatio`.
2.  **Logika:** AI pochop칤, 쬰 `Bucket` je jen p콏evlek.
3.  **Matematika:** Zavede pravidlo, 쬰 `1 Bucket` se automaticky p콏epo캜칤t치 na `17 Jars` p콏i ode캜tu ze skladu.
4.  **Zobrazen칤:** Zajist칤, 쬰 na webu uvid칤te "Skladem: 5 Bucket콢", pokud m치te fyzicky "85 D칩z" (85 / 17 = 5), ani byste musel ru캜n캩 udr쬺vat sklad Bucket콢.

Tento p콏칤stup je pro v치코 WMS nejbezpe캜n캩j코칤 a nejm칠n캩 n치chyln칳 k chyb치m.